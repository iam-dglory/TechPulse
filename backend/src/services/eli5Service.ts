import { AppDataSource } from '../../ormconfig';
import { Story } from '../models/story';
import { openai } from '../services/scoring/openAiScorer';

interface ELI5Result {
  simpleSummary: string;
  technicalSummary: string;
  explanation?: string;
}

class Eli5Service {
  private storyRepository = AppDataSource.getRepository(Story);

  /**
   * Generate ELI5 explanations for a story
   */
  async explainTextForStory(storyId: string, mode: 'simple' | 'technical' | 'both' = 'both'): Promise<ELI5Result> {
    try {
      const story = await this.storyRepository.findOne({ where: { id: storyId } });
      
      if (!story) {
        throw new Error('Story not found');
      }

      // Check if we already have cached summaries
      if (mode === 'both' && story.simpleSummary && story.technicalSummary) {
        return {
          simpleSummary: story.simpleSummary,
          technicalSummary: story.technicalSummary,
          explanation: 'Cached from previous generation'
        };
      }

      if (mode === 'simple' && story.simpleSummary) {
        return {
          simpleSummary: story.simpleSummary,
          technicalSummary: '',
          explanation: 'Cached simple summary'
        };
      }

      if (mode === 'technical' && story.technicalSummary) {
        return {
          simpleSummary: '',
          technicalSummary: story.technicalSummary,
          explanation: 'Cached technical summary'
        };
      }

      // Check if OpenAI is available
      if (!process.env.OPENAI_API_KEY) {
        console.log('OpenAI API key not found, generating basic summaries');
        return this.generateBasicSummaries(story, mode);
      }

      // Generate with OpenAI
      const openAIResult = await this.generateOpenAISummaries(story, mode);
      
      // Cache the results
      await this.cacheSummaries(storyId, openAIResult);

      return openAIResult;
    } catch (error) {
      console.error('Error generating ELI5 explanations:', error);
      
      // Fallback to basic summaries
      const story = await this.storyRepository.findOne({ where: { id: storyId } });
      if (story) {
        return this.generateBasicSummaries(story, mode);
      }
      
      throw error;
    }
  }

  /**
   * Generate summaries using OpenAI
   */
  private async generateOpenAISummaries(story: Story, mode: 'simple' | 'technical' | 'both'): Promise<ELI5Result> {
    try {
      const systemPrompt = `You are a tech journalist and educator who specializes in explaining complex technology stories in accessible ways. You write for TexhPulze, a platform that helps people understand technology's impact on society.

Your task is to create two versions of explanations for tech stories:

1. SIMPLE VERSION (ELI5 - Explain Like I'm 5): 
   - Use everyday language and analogies
   - Avoid jargon and technical terms
   - Focus on what this means for regular people
   - Keep it under 150 words
   - Make it engaging and relatable

2. TECHNICAL VERSION:
   - Use precise technical language
   - Include relevant technical details
   - Explain the underlying mechanisms
   - Keep it under 200 words
   - Maintain accuracy and depth

Always be objective, fact-based, and help readers understand both the technology and its implications.`;

      const userPrompt = `Please create ${mode === 'both' ? 'both simple and technical' : mode} explanations for this tech story:

**Title:** ${story.title}

**Content:** ${story.content}

**Sector:** ${story.sectorTag}
${story.company ? `**Company:** ${story.company.name}` : ''}

**Hype Score:** ${story.hypeScore}/10
**Ethics Score:** ${story.ethicsScore}/10

Please format your response as JSON:
{
  "simpleSummary": "Simple explanation here...",
  "technicalSummary": "Technical explanation here...",
  "explanation": "Brief note about your approach"
}

${mode !== 'both' ? `Only provide the ${mode} version in the appropriate field.` : ''}`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature: 0.7,
        max_tokens: 800,
      });

      const content = response.choices[0]?.message?.content;
      if (!content) {
        throw new Error('No response from OpenAI');
      }

      // Parse JSON response
      const parsed = JSON.parse(content);
      
      return {
        simpleSummary: parsed.simpleSummary || '',
        technicalSummary: parsed.technicalSummary || '',
        explanation: parsed.explanation || 'Generated by OpenAI GPT-4'
      };
    } catch (error) {
      console.error('OpenAI generation error:', error);
      throw error;
    }
  }

  /**
   * Generate basic summaries without OpenAI
   */
  private generateBasicSummaries(story: Story, mode: 'simple' | 'technical' | 'both'): ELI5Result {
    const result: ELI5Result = {
      simpleSummary: '',
      technicalSummary: '',
      explanation: 'Generated using basic template (OpenAI not available)'
    };

    if (mode === 'simple' || mode === 'both') {
      result.simpleSummary = this.generateSimpleSummary(story);
    }

    if (mode === 'technical' || mode === 'both') {
      result.technicalSummary = this.generateTechnicalSummary(story);
    }

    return result;
  }

  /**
   * Generate a simple summary using template
   */
  private generateSimpleSummary(story: Story): string {
    const companyText = story.company ? ` from ${story.company.name}` : '';
    const sectorText = story.sectorTag ? ` in the ${story.sectorTag} sector` : '';
    
    let summary = `This story is about ${story.title.toLowerCase()}${companyText}${sectorText}. `;
    
    // Add content summary (first 200 characters, simplified)
    const contentPreview = story.content
      .substring(0, 200)
      .replace(/[^\w\s]/g, '') // Remove special characters
      .toLowerCase();
    
    summary += `The main points discussed include: ${contentPreview}... `;
    
    // Add impact assessment based on scores
    if (story.hypeScore >= 7) {
      summary += `This appears to be a highly hyped story that may have significant implications. `;
    }
    
    if (story.ethicsScore <= 3) {
      summary += `There are some ethical concerns raised by this development. `;
    }
    
    summary += `Understanding this story helps you stay informed about how technology affects your daily life.`;
    
    return summary;
  }

  /**
   * Generate a technical summary using template
   */
  private generateTechnicalSummary(story: Story): string {
    const companyText = story.company ? ` by ${story.company.name}` : '';
    const sectorText = story.sectorTag ? ` in the ${story.sectorTag} sector` : '';
    
    let summary = `${story.title}${companyText} represents a development${sectorText}. `;
    
    // Add technical context
    summary += `The story discusses technical aspects including: ${story.content.substring(0, 300)}... `;
    
    // Add scoring context
    summary += `Based on our analysis, this story has a hype score of ${story.hypeScore}/10 `;
    summary += `and an ethics score of ${story.ethicsScore}/10. `;
    
    // Add impact tags context
    if (story.impactTags && story.impactTags.length > 0) {
      summary += `Key impact areas include: ${story.impactTags.join(', ')}. `;
    }
    
    summary += `This technical assessment helps evaluate the credibility and implications of the claims made.`;
    
    return summary;
  }

  /**
   * Cache summaries in the database
   */
  private async cacheSummaries(storyId: string, summaries: ELI5Result): Promise<void> {
    try {
      const updateData: Partial<Story> = {};
      
      if (summaries.simpleSummary) {
        updateData.simpleSummary = summaries.simpleSummary;
      }
      
      if (summaries.technicalSummary) {
        updateData.technicalSummary = summaries.technicalSummary;
      }

      // Update eli5Summary to the simple version if it exists
      if (summaries.simpleSummary && !updateData.eli5Summary) {
        updateData.eli5Summary = summaries.simpleSummary;
      }

      await this.storyRepository.update(storyId, updateData);
      console.log(`Cached ELI5 summaries for story: ${storyId}`);
    } catch (error) {
      console.error('Error caching summaries:', error);
    }
  }

  /**
   * Get cached summary for a story
   */
  async getCachedSummary(storyId: string, mode: 'simple' | 'technical'): Promise<string | null> {
    try {
      const story = await this.storyRepository.findOne({ 
        where: { id: storyId },
        select: ['simpleSummary', 'technicalSummary', 'eli5Summary']
      });
      
      if (!story) return null;

      if (mode === 'simple') {
        return story.simpleSummary || story.eli5Summary;
      } else {
        return story.technicalSummary;
      }
    } catch (error) {
      console.error('Error getting cached summary:', error);
      return null;
    }
  }

  /**
   * Clear cached summaries (for regeneration)
   */
  async clearCachedSummaries(storyId: string): Promise<void> {
    try {
      await this.storyRepository.update(storyId, {
        simpleSummary: null,
        technicalSummary: null,
        eli5Summary: null
      });
      console.log(`Cleared cached summaries for story: ${storyId}`);
    } catch (error) {
      console.error('Error clearing cached summaries:', error);
    }
  }

  /**
   * Batch generate summaries for multiple stories
   */
  async batchGenerateSummaries(storyIds: string[], mode: 'simple' | 'technical' | 'both' = 'both'): Promise<Record<string, ELI5Result>> {
    const results: Record<string, ELI5Result> = {};
    
    // Process in batches to avoid rate limits
    const batchSize = 5;
    for (let i = 0; i < storyIds.length; i += batchSize) {
      const batch = storyIds.slice(i, i + batchSize);
      
      const batchPromises = batch.map(async (storyId) => {
        try {
          const result = await this.explainTextForStory(storyId, mode);
          results[storyId] = result;
        } catch (error) {
          console.error(`Error generating summary for story ${storyId}:`, error);
          results[storyId] = {
            simpleSummary: '',
            technicalSummary: '',
            explanation: 'Error generating summary'
          };
        }
      });
      
      await Promise.all(batchPromises);
      
      // Add delay between batches to respect rate limits
      if (i + batchSize < storyIds.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    return results;
  }
}

export const eli5Service = new Eli5Service();
export default eli5Service;

